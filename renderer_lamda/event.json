{
  "python_code": "from manim import *\n\nclass QuickSortAnimation(Scene):\n    \"\"\"\n    Manim scene to visualize the QuickSort algorithm.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initializes the scene with the array to be sorted and empty lists\n        for Manim objects (rectangles and texts).\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        # The array of numbers to be sorted\n        self.array = [5, 2, 8, 1, 9, 4, 7, 6, 3]\n        # List to hold the Manim Rectangle objects representing array elements\n        self.rects = []\n        # List to hold the Manim Text objects representing the numbers\n        self.texts = []\n        # List to hold the colors of the rectangles for visualization\n        self.colors = [WHITE] * len(self.array)\n\n    def construct(self):\n        \"\"\"\n        Constructs the Manim scene. Sets up the initial array visualization\n        and then runs the quicksort animation.\n        \"\"\"\n        # Set up the initial visual representation of the array\n        self.setup_array()\n        # Start the quicksort process on the entire array\n        self.quicksort(0, len(self.array) - 1)\n        # Wait for a few seconds at the end of the animation\n        self.wait(2)\n\n    def setup_array(self):\n        \"\"\"\n        Creates the initial Rectangle and Text objects for each element\n        in the array and positions them on the screen.\n        \"\"\"\n        for i, num in enumerate(self.array):\n            # Create a rectangle for the current number\n            rect = Rectangle(width=0.7, height=0.7, color=WHITE)\n            # Create text for the current number\n            text = Text(str(num)).scale(0.6)\n            # Position the text at the center of the rectangle\n            text.move_to(rect.get_center())\n            # Position the rectangle horizontally based on its index\n            # Adjust the positioning parameters as needed for your scene layout\n            rect.move_to(LEFT * (len(self.array) / 2 - 0.5 - i) * 0.8 + DOWN * 2)\n            # Add the created rectangle and text to their respective lists\n            self.rects.append(rect)\n            self.texts.append(text)\n        # Play an animation to create all rectangles and texts\n        self.play(*[Create(rect) for rect in self.rects], *[Create(text) for text in self.texts])\n        # Wait for a moment after creating the initial array\n        self.wait(1)\n\n    def quicksort(self, low, high):\n        \"\"\"\n        The main QuickSort function. Sorts the sub-array from index low to high.\n        Recursively calls itself for the partitions.\n        \"\"\"\n        # Base case: if the sub-array has one or no elements, it's already sorted\n        if low < high:\n            # Partition the array and get the pivot index\n            pi = self.partition(low, high)\n            # Recursively sort the sub-array before the pivot\n            self.quicksort(low, pi - 1)\n            # Recursively sort the sub-array after the pivot\n            self.quicksort(pi + 1, high)\n\n    def partition(self, low, high):\n        \"\"\"\n        Partitions the sub-array around a pivot element (the last element).\n        Elements smaller than the pivot are moved to the left, and elements\n        greater than the pivot are moved to the right.\n        \"\"\"\n        # Choose the last element as the pivot\n        pivot = self.array[high]\n        # Index of the smaller element\n        i = low - 1\n\n        # Highlight the pivot element in YELLOW\n        self.set_color(high, YELLOW)\n        self.wait(0.5)\n\n        # Iterate through the sub-array from low to high-1\n        for j in range(low, high):\n            # Highlight the current element being considered in BLUE\n            self.set_color(j, BLUE)\n            self.wait(0.5)\n            # If the current element is less than or equal to the pivot\n            if self.array[j] <= pivot:\n                # Increment the index of the smaller element\n                i += 1\n                # Swap the current element with the element at index i\n                self.swap(i, j)\n            # Reset the color of the current element to WHITE\n            self.set_color(j, WHITE)\n\n        # Swap the pivot element (at high) with the element at i + 1\n        self.swap(i + 1, high)\n        # Highlight the pivot's final position in GREEN\n        self.set_color(i + 1, GREEN)\n        # Reset the original pivot position color to WHITE\n        self.set_color(high, WHITE)\n\n        # Return the partitioning index (the final position of the pivot)\n        return i + 1\n\n    def swap(self, a, b):\n        \"\"\"\n        Swaps the elements at indices a and b in both the array and\n        their corresponding Manim objects (rectangles and texts).\n        Plays an animation to show the swap visually.\n        \"\"\"\n        # Only perform the swap if the indices are different\n        if a != b:\n            # Swap colors (though colors are managed by set_color, this keeps the color list consistent)\n            self.colors[a], self.colors[b] = self.colors[b], self.colors[a]\n            # Swap the numbers in the array\n            self.array[a], self.array[b] = self.array[b], self.array[a]\n\n            # Play animation to move the rectangles and texts to their new positions\n            self.play(\n                self.rects[a].animate.move_to(LEFT * (len(self.array) / 2 - 0.5 - a) * 0.8 + DOWN * 2),\n                self.rects[b].animate.move_to(LEFT * (len(self.array) / 2 - 0.5 - b) * 0.8 + DOWN * 2),\n                self.texts[a].animate.move_to(LEFT * (len(self.array) / 2 - 0.5 - a) * 0.8 + DOWN * 2),\n                self.texts[b].animate.move_to(LEFT * (len(self.array) / 2 - 0.5 - b) * 0.8 + DOWN * 2)\n            )\n\n            # Swap the Manim objects in their lists to maintain correspondence with the array\n            self.rects[a], self.rects[b] = self.rects[b], self.rects[a]\n            self.texts[a], self.texts[b] = self.texts[b], self.texts[a]\n\n            # Wait for a moment after the swap animation\n            self.wait(0.5)\n\n    def set_color(self, index, color):\n        \"\"\"\n        Sets the color of the rectangle at the given index and plays an animation\n        to show the color change.\n        \"\"\"\n        # Update the color in the color list\n        self.colors[index] = color\n        # Play an animation to change the color of the rectangle\n        self.play(self.rects[index].animate.set_color(color))\n",
  "id": "test-332"
}
